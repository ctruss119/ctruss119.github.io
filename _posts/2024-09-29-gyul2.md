---
layout: post
title: "학교에 있는 4090 서버에 Docker Container 생성하기"
---

<h2>목차</h2>
<ul>
  <li><a href="#section1">1. 도커의 개념 이해하기 </a></li>   
  (1) 컨테이너 / (2) 도커 / (3) VM과 도커의 차이점 / (4) 이미지 / (5) 참고자료 
  <li><a href="#section2">2. 도커 생성하기 </a></li>
  (1) 대장 서버 접속하기   / 
(2) 원하는 이미지를 다운 받거나 있는지 확인한다.   / 
(3) 원하는 이미지를 적재한다.   / 
(4) ssh 설정에 필요한 것들을 설치한다   / 
(5) 컨테이너 내부 포트를 열어 비밀번호와 원격 접속을 설정한다   / 
(6) -v 기반으로 volume 잡고 생성한다는건 뭘까

  <li><a href="#section3">3. 도커 관련 명령어 </a></li>
  <li><a href="#section4">4. 도커 파일 작성하기 </a></li>
</ul>
-------------------------------------------------------------------   

# <a id="section1"></a>1. 도커의 개념 이해하기 

## (1) 컨테이너
프로세스 격리 기술중 하나로 **사용자가 사용할 라이브러리, 시스템 도구, 코드, 환경 설정 등 소프트웨어 실행에 필요한 모든 것을 패키징한 계층**이다. 여러 종류의 컨테이너가 동일한 시스템에서 실행되고  OS를 다른 컨테이너와 공유할 수 있으며, 각 컨테이너는 사용자 공간에서 독립적인 프로세스로 실행된다. (또, 도커 컨테이너는 이미지로부터 생성되어 배포된 인스턴스라고도 볼 수 있다.)

(1) 가상환경(VM)보다 메모리 공간을 적게 차지하고 더 많은 Application을 처리할 수 있고   
(2) 다른 컨테이너나 시스템과 충돌 없이 동작할 수 있고,   
(3) 더 적은 수의 vm또는 os를 필요로 하고,   
(4) 시스템의 커널을 공유하므로 가상 머신보다 빠르게 시작하고 멈출 수 있고,   
(5) 어떤 운영환경으로도 배포, 이동이 쉽기 때문에   
이미 다양한 어플리케이션들이 컨테이너 환경에서 실행되고 있다.   


**다만 이런 컨테이너가 많을수록 관리가 어려워지는데 이를 해결하기 위해 나온 것이 도커다.**


## (2) 도커      
컨테이너 가상화 기술로, 응용 프로그램과 의존성을 하나의 컨테이너에 패키징해 컨테이너 단위로 배포하고 실행할 수 있도록 하는 오픈소스 플랫폼. 

한 컴퓨터 안에 여러개의 시스템 및 환경설정들을 충돌하지 않고 동시에 사용할 수 있도록 격리시켜 사용할 수 있다. 호스트OS의 커널을 공유해 다양한 어플리케이션을 설치/운영하여 하나의 서버처럼 사용할 수 있다.   

기존의 가상머신(가상환경을 활용해 새로운 os를 깔아 설치)과 달리 도커는 os전체를 가상화하지 않고 호스트 OS의 커널을 공유하면서 필요한 실행 환경만을 독립적으로 분리해 사용한다. 이로 인해 설치 용량이 작고 실행 속도가 빠르다.   

* 핵심 용어
  * OS 가상화   
    사용하려는 OS를 커널만 공유하여 프로세스로 실행하는 것. 
  * 커널   
    하드웨어 자원을 관리하고 하드웨어와 프로세스 사이의 인터페이스 역할을 수행하는 요소
  * 레이어   
    기존 도커 이미지에서 추가적인 파일이 필요할 때 파일을 추가하기 위한 개념
  * 도커 이미지   
    컨테이너 실행에 필요한 파일과 설정값 등을 포함하고 있는 것으로 같은 이미지로 여러 개의 컨테이너 생성 가능
  * 도커 컨테이너   
    호스트 OS 상에 어플리케이션을 동작시키기 위해 필요한 라이브러리나 애플리케이션을 하나로 모은 것, 또는 도커 임미지를 실행한 상태
  * Immutable Infrastructure   
    OS와 서비스환경(코드, 툴, 라이브러리 등)을 분리하여 이해하고, 서비스환경은 이미지화(실행파일화)해 배포한 뒤 가급적 변경하지 않고 사용하는 구조. 도커가 이 패러다임을 기반으로 탄생한 도구다. 


* 장점 
  * 빠른 설치   
    어플리케이션을 설치하고 사용하는 것에 최소한의 시간과 용량을 소비
  * 이식성   
    어플리케이션의 설치 파일들이 하나의 컨테이너에 존재하기 때문에 호스트의 커널이나 플랫폼 버전에 관계 없이 도커만 실행할ㄴㄹ수 있음면 사용 가능함ㅁ. 개발 환경과 실제 서버 환경이 달라 생기는 문제가 없다. 도커를 사용하면 개발자가 특정 소프트웨어를 개발한 환경과 동일한 환경을 어디서든 쉽게 재현할 수 있기 때문에, 코드가 어디서든 동일하게 작동하는 것을 보장할 수 있다. 
  * 컴포넌트 재사용   
    이전 레이어에서 컴포넌트들을 재사용하기 때문에 도커를 가볍게 만들 수 있음ㅁ
  * 쉬운 유지관리   
    어플리케이션 종속성에 관한 문제들에 대해 유지관리가 용의함

## (3) VM과 도커의 차이점 
### 도커의 아키텍쳐
하드웨어의 자원을 나눠 사용하는 것이 아니라 **호스트 위에 도커 엔진을 통해 바로 애플리케이션과 애플리케이션에서 필요로 하는 자원을 패키징화하여 바로 사용하는 개념**이기 때문에 **소모되는 자원이 VM에 비해 매우 작음.** 애플리케이션에서 필요로하는 자원은 도커 이미지로 도커 레지스트리 또는 도커 허브에 저장되어 있는데 도커 이미지에 접근하여 이를 실행해 컨테이너를 생성할 수 있다. 컨테이너를 생성하여 실행하게 되면 애플리케이션 배포가 완료된다. 

### VM과 VM의 아키텍쳐 
VM은 물리적 시스템 OS 위에 논리적 가상 OS를 올려서 독립적인 동작이 가능하도록 하는 시스템 차원의 가상 머신   
* 호스트OS: VM이 설치되는 기본 OS (맥, 리눅스, 윈도우 등)
* 게스트 OS: 호스트 OS위에 설치되는 가상 OS
* 하이퍼바이저: 호스트OS 위에 VM을 생성하고 실행하는 프로세스 (VMware, virturebox 등)
* 각 VM이 동일한 OS를 사용해도 데이터를 공유하지 않음 -> 독립된 실행환경   

VM의 아키텍쳐는 하드웨어 자원을 공유해 사용하는 것임. 때문에 하나의 가상공간이 생성될 때마다 하드웨어의 자원을 일부 공유받아 사용하게 됨. 다만 각각의 가상공간은 서로 간섭하지 않기 때문에 한 공간에서의 문제가 다른 공간에서까지 영향을 끼치지 않는다. 근데 os, 라이브러리의 전체 복사본을 많이 포함하다보니까 부팅 속도가 느려질 수 있다. 

### 도커와 VM의 차이점 
VM은 각각의 공간이 하드웨어의 자원을 일부 공유받아 서로 다른 공간처럼, 개별적인 공간인 것처럼 사용한다. 그러므로 각 가상공간마다 OS를 설치해야 한다.    
도커는 하나의 OS에서 각각의 컨테이너를 띄워 앱을 실행하는 구조다.   
속도적인 측면에서는 도커가 유리, OS의 보안적인 측면에서는 VM이 유리함.

<style>
  .image-container {
    display: flex;
    justify-content: space-around;
    align-items: center;
  }

  .image-container figure {
    margin: 0;
    text-align: center;
    width: 20%;
  }

  .image-container img {
    width: 20%;
  }
</style>

<div class="image-container">
  <figure>
    <img src="https://raw.githubusercontent.com/ctruss119/ctruss119.github.io/master/assets/img/containerarch.png" alt="도커 아키텍쳐">
    <figcaption>도커 아키텍쳐</figcaption>
  </figure>

  <figure>
    <img src="https://raw.githubusercontent.com/ctruss119/ctruss119.github.io/master/assets/img/vmarch.png" alt="VM 아키텍쳐">
    <figcaption>VM 아키텍쳐</figcaption>
  </figure>
</div>




## (4) 이미지 Docker Image
도커에서 서비스 운영에 필요한 / 특정 프로세스를 실행하기 위한 모든 파일, 환경, 의존성, 설정값,  서버 프로그램, 소스코드 및 라이브러리, 컴파일된 실행 파일 등을 묶는 형태. 그래서 더이상 파일을 컴파일하거나 추가 설치할 필요 없는 상태다.   
도커 이미지는 실행 가능한 상태로 저장되며, 이를 기반으로 컨테이너를 생성할 수 있다. 즉, 이미지는 컨테이너를 만들기 위한 기본 단위이며, 컨테이너는 이미지를 실행한 상태로 볼 수 있다.   

(ex. 우분투 이미지는 우분투를 실행하기 위한 모든 파일을 갖고 있음. 우분투 이미지를 기반응로 컨테이너 생성해서 실행하면 우분투 됨.) 

**레이어**   
이미지는 여러 개의 읽기 전용 레이어로 구성되고, 파일이 추가되면 새로운 레이어가 생성됨. 기존 이미지에 추가적인 파일이 필요할 때 다시 다운로드 받는 방법이 아니라 해당 파일을 추가하는 개념. 도커는 이러한 여러 개의 레이어를 묶어서 하나의 파일 시스템으로 사용한다. 따라서 이미지는 레이어와 같은 의미로 사용되기도 한다.

  <figure>
    <img src="https://github.com/ctruss119/ctruss119.github.io/blob/master/assets/img/imagelayer.png" alt="레이어와 이미지">
    <figcaption>레이어와 이미지</figcaption>
  </figure>



**이미지의 주요 특징**
* 불변성 (immutable)   
  이미지는 한 번 만들어지면 수정할 수 없고, 항상 동일한 상태를 보장한다.   
  하나의 이미지는 여러 컨테이너를 생성할 수 있고, 컨테이너가 삭제되어도 이미지는 남음. 
* 레이어 구조   
  도커 이미지는 레이어(layer)로 구성되며, 각 레이어는 서로 의존하고 있다.   
  이로 인해 이미지를 효율적으로 저장하고 전송할 수 있다.
* 저장소(Docker Hub)   
  이미지를 저장하고 공유할 수 있는 저장소가 있으며, 도커 허브(Docker Hub)를 통해 여러 사람이 이미지를 쉽게 다운로드할 수 있다. 

 

## (5) 참고자료
[참고영상](https://www.youtube.com/watch?v=WEcjf6UMzmQ)
[참고 포스트](https://hoon93.tistory.com/41)
[도커 사이트?](https://phoenixnap.com/kb/docker-image-vs-container)   

# <a id="section2"></a>2. 도커 생성하기
선배님 pdf를 참고해서 진행했다. 


## (1) 대장 서버 접속하기   
```
ssh {사용자 계정}@{IP주소} -p {포트번호}   
```
{사용자 계정}으로 {IP주소}를 가진 서버에서 SSH를 통해 {포트번호}번 포트로 접속한다. 
나는 이게 자꾸 안들어가졌는데......    
```
ssh -v {사용자 계정}@{IP주소} -p {포트번호}   
```
이 경우 위 명령어를 사용해보면 상세 모드 옵션을 통해 디버깅 정보와 접속 실패 여부 등등을 확인할 수 있다. 


## (2) 원하는 이미지를 다운 받거나 있는지 확인한다. 
https://hub.docker.com/에서 원하는 걸 pull해서 받아온다.  
사이트에서 원하는 이미지에 들어가 Docker Pull Command를 그대로 복사해오면 된다.    
나의 경우 시험삼아 python과 tensorflow를 다운받았다. 
```
docker pull tensorflow/tensorflow
```


## (3) 원하는 이미지를 적재한다. 
```
 docker run --gpus all -it -v <연결하고 싶은 폴더>/workspace --privileged -p ?:! -- name KGR {도커 이미지}
```
* docker run: 새로운 도커 컨테이너를 생성한다
* --gpus: 모든 모든 GPU를 컨테이너에서 사용할 수 있도록 설정한다. 
* -it: 상호작용 모드로 컨테이너를 실행한다. -i는 인터랙티브 모드로, -t는 터미널을 연결합니다.
* -v <연결하고 싶은 폴더>: 호스트의 <연결하고 싶은 폴더> 디렉토리를 컨테이너 내의 디렉토리와 연결한다.
* --privileged: 컨테이너에 대해 모든 호스트 장치와 시스템 호출에 대한 접근을 허용한다.
* -p ?:!  : 호스트의 ? 포트를 컨테이너의 !포트(SSH 포트)와 매핑한다. 
* --name KGR: 컨테이너의 이름을 KGR로 설정한다.
* {도커 이미지}: 사용할 도커 이미지의 이름.   
~~나의 경우 KGR이라는 도커를 만들었는데 비밀번호를 까먹어서 다시 만들어야 할 것 같다..~~

## 연결?

## (4) ssh 설정에 필요한 것들을 설치한다 
```
apt-get update
```
패키지 목록을 업데이트하여 최신 버전 정보를 가져d온ㄷ.
```
apt-get install vim nano net-tools openssh-server
```
필요한 패키지들을 설치한다. 


## (5) 컨테이너 내부 포트를 열어 비밀번호와 원격 접속을 설정한다
```
vi /etc/ssh/sshd_config
```
 /etc/ssh/sshd_config 파일은 SSH 서버의 다양한 설정을 관리하는 곳이다.   
 키보드 i를 누르면 삽입 모드로 전환되어 텍스트를 수정할 수 있다.    
 파일을 연 다음에 PermitRootLogin 라인을 찾아 주석을 제거하고 원하는 값을 설정한다.    
 이때 yes는 루트 로그인 허용을 의미한다.    
 Esc를 누르고 :wq를 입력한 후 Enter를 누르면 저장하고 종료된다.    
 Esc느느 삽입 모드 해제,  :는 작성할 준비가 되었다는 것, w는 저장, q는 나간다는 것.    
 이후 service ssh restart 해준다.    
 ```
passwd
```
위 명령어를 통해 비번을 설정하고 나면 운격으로 접속할 수 있다. 

## (6) -v 기반으로 volume 잡고 생성한다는건 뭘까
```
docker run --gpus all -it -v mmm:/workspace --privileged -p 66667:22 --name MMM nvcr.io/nvidia/pytorch:24.05-py3
```
여기서 **-v mmm:/workspace**는 볼륨 마운트를 설정하는 부분입니다.

볼륨 마운트 이해하기
-v mmm:/workspace:
mmm: 이 부분은 호스트 시스템의 로컬 폴더를 지정합니다. 즉, Docker가 실행되는 컴퓨터(호스트)의 경로입니다.
/workspace: 이 부분은 컨테이너 내의 경로입니다.
이 설정은 호스트의 mmm 폴더를 컨테이너의 /workspace 폴더와 연결하여 두 위치 간에 파일을 공유할 수 있게 해줍니다.

볼륨 마운트를 통해 호스트의 폴더를 컨테이너의 특정 경로와 연결하여 파일을 공유할 수 있습니다.
명령어에서 mmm을 호스트의 절대 경로로 변경하면 원하는 폴더를 컨테이너와 공유할 수 있습니다.
이렇게 설정하면 컨테이너와 호스트 시스템 간의 파일 작업을 쉽게 할 수 있습니다.



# <a id="section3"></a>3. 도커 관련 명령어
```
# 도커 옛버전 삭제
sudo apt-get remove docker docker-engine docker.io containerd runc

# 도커 설치
sudo apt-get install docker-ce docker-ce-cli containerd.io

# 설치 확인
docker --version

# 도커 실행 (택1) 
sudo systemctl status docker
sudo /etc/init.d/docker start

# 도커 이미지 빌드
docker image bulid -t 이미지명[:태그명] Dockerfile경로

# 도커 이미지 pull
docker image pull 레파지토리명[:태그명]

# 실행 중인 컨테이너 목록 확인
docker ps

# 컨테이너 생성
docker run -p <Host port>:<Container port> -it --gpus all --name {이미지 이름}

# 전체 컨테이너 목록 확인
docker ps -a

# 컨테이너 시작
docker start 컨테이너ID

# 컨테이너 접속 (택1) 
docker attach 컨테이너ID
docker exec -it <컨테이너_ID 또는 이름> /bin/bash

# 컨테이너 중지
docker stop 컨테이너ID

# 컨테이너 생성 ㅁ및 시작
docker run 컨테이너ID

# 컨테이너 생성, 접속
docker run -it 컨테이너ID

# 컨테이너 삭제
docker rm 컨테이너ID

# 컨테이너 내부 포트 열기
vi /etc/ssh/sshd_config

# 실행되고 있던 컨테이너 접속
docker exec -it 컨테이너ID /bin/bash

# 컨테이너 나오기
exit

# 컨테이너 강제 종료
docker kill <컨테이너_ID 또는 이름>

#컨테이너 로그 확인
docker logs <컨테이너_ID 또는 이름>

# ssh 서비스 시작
service ssh start

# ssh 서비스 재시작
service ssh restart

# 도커 이미지 보기
docker images

# 도커 이미지 다운로드
docker pull <이미지명>

# 도커 이미지 삭제
docker rmi <이미지_ID 또는 이미지명>

# 도커 이미지 생성 (도커파일로)
docker build -t <이미지명>:<태그> <Dockerfile 위치>

# 실행 중인 컨테이너의 리소스 사용량 확인
docker stats

# 컨테이너의 파일 시스템 확인
docker inspect <컨테이너_ID 또는 이름>

# 실행 중인 모든 컨테이너를 한눈에 확인 
docker top

```

# <a id="section4"></a>4. 도커 파일 작성하기

### 4. 도커파일
**도커파일(Dockerfile)**은 도커 이미지를 만들기 위한 설정 파일입니다. 이 파일에는 도커 이미지의 빌드 과정이 순차적으로 정의되어 있습니다. 쉽게 말해, 도커파일은 컨테이너 환경을 만들기 위해 어떤 OS를 사용할지, 어떤 소프트웨어를 설치할지, 환경 설정을 어떻게 할지 등을 기술한 스크립트입니다.

도커파일의 구성:
FROM: 베이스 이미지(기본적으로 사용할 운영체제 또는 환경)를 지정합니다.
RUN: 컨테이너 안에서 실행할 명령을 정의합니다. 예를 들어, 필요한 소프트웨어 설치 명령 등을 추가할 수 있습니다.
COPY: 파일을 호스트 시스템에서 컨테이너로 복사하는 명령입니다.
CMD: 컨테이너가 시작될 때 실행될 명령을 정의합니다.


```
#도커파일의 예시
FROM node  #운영체제 이미지(베이스 이미지)

RUN npm install  #실행할 명령어(새로운 레이어에서 명령어를 실행하고 새로운 이미지를 생성)

COPY . /app  #파일 복사(build 명령 중간에 호스트의 파일 또는 폴더 이미지를 가져오는 것)

WORKDIR /app  #작업 디렉토리(작업 디렉토리로 해당 디렉토리가 없으면 새로 생성)

EXPOSE 80  #포트 노출(Dockerfile의 빌드로 생성도니 이미지에서 열어줄 포트를 의미)

CMD ["node", "server.js"]  #컨테이너 명령 실행(컨테이너를 생성 및 실행할 때 사용되는 명령어)

# 베이스 이미지를 선택
FROM ubuntu:latest

# 소프트웨어 패키지 업데이트 및 설치
RUN apt-get update && apt-get install -y nginx

# 호스트 시스템의 파일을 컨테이너로 복사
COPY ./index.html /var/www/html/index.html

# 컨테이너가 실행될 때 Nginx 서버를 시작
CMD ["nginx", "-g", "daemon off;"]
````

